# 🗺️ Roadmap Stratégique - ÉMERGENCE V8.0

*Version : 2025-09-14*

Cette feuille de route consolide la vision V8 en décrivant l’état courant et les jalons à venir. Elle articule les piliers (chat multi-agents, mémoire progressive, RAG, cockpit, débats) et priorise les chantiers en fonction des risques identifiés.

---

## Principes directeurs
- **Architecture modulaire** : chaque capability (chat, mémoire, documents, débats, cockpit) est encapsulée (backend service + module frontend dédié).
- **Sécurité & Auth** : tout appel REST/WS requiert un ID token (mode dev activable via `AUTH_DEV_MODE`).
- **Observabilité** : instrumentation native (`ws:model_info`, `ws:memory_banner`, `dashboard`), scripts de smoke-tests pour valider les invariants.
- **Sobriété des coûts** : orchestration multi-fournisseurs (Google → Anthropic → OpenAI) + suivi des coûts (`DashboardService`).

## Phase 2 : La Mémoire Vive (Fondation)
* **Objectif principal :** Donner à ÉMERGENCE une mémoire persistante, intelligente et capable d’oubli sélectif.
* **Concepts clés :**
    - **Sauvegarde intégrale :** Stockage de chaque session (dialogues, débats, métadonnées) dans un champ JSON unique.
    - **Analyse sémantique :** Extraction automatique de thèmes, concepts et entités de chaque session.
    - **Score de vivacité & oubli :** Simulation d’un mécanisme d’oubli en faisant décroître un « score de pertinence » dans le temps pour prioriser les souvenirs récents ou importants.
* **État d’avancement (Phase 2 - Mémoire) :**
    - Chaque concept/fait vectorisé embarque des métadonnées de vitalité (`vitality`, `usage_count`, `last_access_at`, `last_decay_at`).
    - Le Jardinier applique à chaque ronde une décroissance progressive (base + bonus selon l’ancienneté) et purge les souvenirs sous le seuil de vivacité.
    - Les rappels conversationnels rehaussent la vitalité des souvenirs consultés et ignorent ceux en dessous du seuil de rappel.
* **Modules impactés/créés :**
    - `core/database.py` (modifié)
    - `core/session_manager.py` (nouveau)
    - `features/memory/analyzer.py` (nouveau)
    - `features/memory/gardener.py` (nouveau, pour l’oubli)
    - `core/temporal_search.py` (nouveau)

---

## État actuel (2025-09)
- **Chat temps réel** : opérationnel via WS + fallback REST. Threads persistés (SQLite) avec hydratation automatique côté front.
- **Mémoire STM/LTM** : `MemoryGardener` et `MemoryAnalyzer` en place (analyse globale ou ciblée, purge STM/LTM). Notifications front via `ws:analysis_status` / `ws:memory_banner`.
- **RAG documents** : upload `.pdf|.txt|.docx`, vectorisation Chroma, sources affichées dans le chat.
- **Débats multi-agents** : orchestrés par `DebateService`, synthèse finale et export.
- **Cockpit** : agrégation coûts/sessions/documents exposée via `/api/dashboard/costs/summary` et rendue dans `DashboardModule`.

---

## Roadmap structurée

### P2 — Mémoire vive & consolidation continue (En cours)
- Optimiser l’expérience utilisateur en cas d’échec auth (toasts explicites, re-prompt GIS).
- Afficher l’historique de consolidation (`GET /api/memory/tend-garden`) dans l’UI mémoire.
- Couvrir `memory:clear` par tests automatisés (smoke + unitaires ciblés).

### P3 — RAG maîtrisé (Stabilisé)
- Étendre les formats supportés (Markdown, HTML léger) en assurant la purge d’embeddings.
- Ajout de filtres RAG côté UI (sélection docs par thread).

### P4 — Interaction vocale (À cadrer)
- POC micro front (enregistrement + streaming) + intégration STT/TTS avec fallback texte.
- Définir la stratégie coût/latence (modèles vocaux vs. LLM existants).

### P5 — Analyse d’images (À venir)
- Inventaire des APIs multimodales compatibles (GPT-4o, Gemini 1.5).
- Adapter `ChatService` pour l’injection d’assets binaires et la diffusion des résultats.

### P6 — Agent connecté (Backlog)
- Design du `WebConnector` (scraping sécurisé, caches).
- Définir les politiques d’usage (quota, journalisation).

### P7 — Cockpit étendu (Itératif)
- Décomposer les coûts par fournisseur/modèle.
- Ajouter la santé des services (vector store, latence WS) et une timeline d’événements.

---

## Étapes immédiates (Priorités Semaine Courante)
1. **Stabilité Auth** : implémenter une remontée visuelle côté front lorsque `ensureCurrentThread()` échoue (message “Connexion requise”).
2. **Tests mémoire** : exécuter `tests/run_all.ps1` + ajouter un scénario ciblé `memory:clear` (script dédié ou extension existant).
3. **Documentation UX** : compléter `docs/Memoire.md` (présent document) avec captures/flows pour guider la QA manuelle.
4. **Surveillance vector store** : planifier un run hebdo de `tests/test_vector_store_reset.ps1` pour sécuriser l’auto-reset.

---

## Risques & points de vigilance
- **Dépendances API** : absence de clé IA → erreur serveur (`500`). Préparer un mode “limité” pour les environnements dépourvus de clés.
- **Téléchargement SBERT** : premier appel long (cache local). Prévoir warm-up lors du déploiement.
- **Échecs silencieux** : beaucoup d’erreurs sont loguées sans feedback utilisateur (auth, WS). Nécessité de toasts/CTA.
- **Vector store** : corruption possible (SQLite). Conserver les backups automatiques `vector_store_backup_*`.

---

## Références
- Architecture détaillée : `docs/architecture/*.md`
- Mémoire progressive : `docs/Memoire.md`
- Tests : `tests/run_all.ps1`, `tests/test_vector_store_reset.ps1`, `tests/test_vector_store_force_backup.ps1`
