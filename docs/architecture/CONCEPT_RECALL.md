# D√©tection et Rappel de Concepts R√©currents ‚Äî √âMERGENCE V8

**Version** : 1.0
**Date** : 2025-10-04
**Auteur** : Claude Code
**Statut** : Proposition technique ‚Äî Validation FG requise

---

## 0. Table des mati√®res

- [1. Objectifs](#1-objectifs)
- [2. √âtat des lieux](#2-√©tat-des-lieux)
- [3. Architecture propos√©e](#3-architecture-propos√©e)
- [4. Impl√©mentation technique](#4-impl√©mentation-technique)
- [5. Contrats API & √©v√©nements](#5-contrats-api--√©v√©nements)
- [6. Plan de d√©ploiement](#6-plan-de-d√©ploiement)
- [7. Tests & validation](#7-tests--validation)
- [8. Checklist de livraison](#8-checklist-de-livraison)

---

## 1. Objectifs

### 1.1. Besoin utilisateur

**Demande initiale** : L'utilisateur souhaite que les agents puissent :
- **D√©tecter automatiquement** quand un sujet/concept a d√©j√† √©t√© abord√© dans l'historique
- **Signaler spontan√©ment** ces r√©currences pendant la conversation
- **Fournir le contexte pr√©cis** : date, heure, thread concern√© et liens conceptuels

### 1.2. Cas d'usage

1. **Rappel proactif en conversation**
   ```
   USER: Je voudrais mettre en place une CI/CD pour le projet
   AGENT: üîó Nous avons d√©j√† abord√© la CI/CD le 2 octobre 2025 √† 14:32
          (thread: "Infrastructure DevOps"). Je peux m'appuyer sur
          ces √©changes pr√©c√©dents pour approfondir.
   ```

2. **Question explicite de l'utilisateur**
   ```
   USER: Est-ce qu'on a d√©j√† parl√© de containerisation ?
   AGENT: ‚úÖ Oui, 3 fois :
          - 28 sept 2025, 10:15 ‚Äî Thread "Migration Docker" (concepts: Docker, Kubernetes)
          - 1 oct 2025, 16:42 ‚Äî Thread "D√©bat architecture" (concepts: microservices)
          - 3 oct 2025, 09:20 ‚Äî Thread actuel (concepts: CI/CD pipeline)
   ```

3. **D√©tection de redondance**
   ```
   AGENT: üí° Je remarque que nous revenons sur le sujet "optimisation
          m√©moire" d√©j√† explor√© le 15 septembre 2025 √† 11:05.
          Souhaitez-vous que je reprenne les conclusions pr√©c√©dentes ?
   ```

---

## 2. √âtat des lieux

### 2.1. Infrastructure existante

#### ‚úÖ **Composants disponibles**

1. **MemoryAnalyzer** ([analyzer.py:52-236](src/backend/features/memory/analyzer.py#L52))
   - Extraction automatique de concepts via LLM (Google ‚Üí Anthropic ‚Üí OpenAI)
   - Sch√©ma JSON structur√© : `summary`, `concepts[]`, `entities[]`
   - Analyse STM (m√©moire courte terme) par session

2. **MemoryGardener** ([gardener.py:347-1764](src/backend/features/memory/gardener.py#L347))
   - Vectorisation des concepts dans `emergence_knowledge` (ChromaDB)
   - M√©tadonn√©es riches : `created_at`, `source_session_id`, `user_id`, `vitality`
   - Syst√®me de decay temporel (vieillissement configurable)
   - Support thread_id pour consolidation cibl√©e

3. **Base de donn√©es**
   - Table `messages` : `id`, `thread_id`, `content`, `created_at`, `session_id`, `user_id`
   - Table `monitoring` : √©v√©nements `knowledge_concept`, `knowledge_fact`, timestamps ISO 8601
   - Collections vectorielles : `emergence_knowledge`, `memory_preferences`

4. **MemoryContextBuilder** ([memory_ctx.py:12-282](src/backend/features/chat/memory_ctx.py#L12))
   - Recherche vectorielle avec filtrage `user_id`
   - Pond√©ration temporelle (boost <7j : +30%, <30j : +15%)
   - Injection pr√©f√©rences actives (confidence ‚â• 0.6)

#### ‚ö†Ô∏è **Limitations actuelles**

1. **Pas de tra√ßabilit√© temporelle fine**
   - Les concepts sont vectoris√©s avec `created_at` mais sans lien explicite vers le message d'origine
   - Impossible de retrouver l'horodatage exact de la premi√®re mention

2. **Pas de d√©tection proactive**
   - L'injection m√©moire est passive (contexte RAG uniquement)
   - Aucun √©v√©nement WebSocket pour signaler les r√©currences

3. **Pas de suivi des occurrences multiples**
   - Un concept peut √™tre mentionn√© 10 fois, mais on ne sait pas quand ni o√π
   - Pas de compteur `mention_count` ou d'historique `thread_ids[]`

4. **Recherche s√©mantique limit√©e**
   - La recherche vectorielle retourne des r√©sultats, mais sans m√©tadonn√©es de "premi√®re occurrence"
   - Pas de clustering conceptuel pour d√©tecter les reformulations (ex: "CI/CD" ‚âà "pipeline automatique")

---

## 3. Architecture propos√©e

### 3.1. Nouveau composant : `ConceptRecallTracker`

**Localisation** : `src/backend/features/memory/concept_recall.py`

**Responsabilit√©s** :

1. **Indexation des mentions** : Associer chaque concept √† ses occurrences pr√©cises
2. **D√©tection en temps r√©el** : Scanner le message utilisateur pour identifier les concepts d√©j√† rencontr√©s
3. **Enrichissement contextuel** : R√©cup√©rer thread_id, timestamps, similitudes s√©mantiques
4. **√âmission d'√©v√©nements** : Publier `ws:concept_recall` quand une r√©currence est d√©tect√©e

### 3.2. Sch√©ma de donn√©es enrichi

#### Extension de `emergence_knowledge` (m√©tadonn√©es vectorielles)

```python
{
    "type": "concept",
    "concept_text": "CI/CD pipeline",
    "user_id": "hash_user_123",
    "source_session_id": "session_abc",
    "thread_id": "thread_xyz",           # ‚Üê NOUVEAU
    "message_id": "msg_789",             # ‚Üê NOUVEAU (premier message mentionnant ce concept)
    "created_at": "2025-10-02T14:32:00+00:00",
    "first_mentioned_at": "2025-10-02T14:32:00+00:00",  # ‚Üê NOUVEAU
    "mention_count": 3,                  # ‚Üê NOUVEAU (nombre de fois o√π ce concept est revenu)
    "thread_ids": ["thread_xyz", "thread_abc", "thread_def"],  # ‚Üê NOUVEAU
    "last_mentioned_at": "2025-10-04T09:20:00+00:00",  # ‚Üê NOUVEAU
    "vitality": 0.95,
    "decay_runs": 0,
    "usage_count": 5
}
```

#### Nouvelle table SQL : `concept_mentions` (optionnel, pour requ√™tes complexes)

```sql
CREATE TABLE IF NOT EXISTS concept_mentions (
    id TEXT PRIMARY KEY,
    concept_id TEXT NOT NULL,            -- lien vers vector ID
    concept_text TEXT NOT NULL,
    thread_id TEXT NOT NULL,
    message_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    mentioned_at TEXT NOT NULL,          -- ISO 8601
    similarity_score REAL,               -- distance cosine vs embedding du concept
    context_snippet TEXT,                -- extrait du message (50 chars avant/apr√®s)
    FOREIGN KEY (thread_id) REFERENCES threads(id) ON DELETE CASCADE,
    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE
);

CREATE INDEX idx_concept_mentions_concept_id ON concept_mentions(concept_id);
CREATE INDEX idx_concept_mentions_user_id ON concept_mentions(user_id);
CREATE INDEX idx_concept_mentions_mentioned_at ON concept_mentions(mentioned_at);
```

**Avantage** : Requ√™tes SQL rapides pour "toutes les mentions du concept X par utilisateur Y, tri√©es par date".

### 3.3. Flux de d√©tection

```mermaid
sequenceDiagram
    participant User
    participant ChatService
    participant ConceptRecallTracker
    participant VectorService
    participant ConnectionManager

    User->>ChatService: Message "Je veux setup une CI/CD"
    ChatService->>ConceptRecallTracker: detect_recurring_concepts(message, user_id, thread_id)

    ConceptRecallTracker->>VectorService: Recherche vectorielle (query: "CI/CD", where: {user_id, type: concept})
    VectorService-->>ConceptRecallTracker: R√©sultats [concept_id_1, concept_id_2...] + m√©tadonn√©es

    ConceptRecallTracker->>ConceptRecallTracker: Filtre similarit√© > 0.75
    ConceptRecallTracker->>ConceptRecallTracker: R√©cup√®re first_mentioned_at, thread_ids[]

    ConceptRecallTracker-->>ChatService: R√©currences d√©tect√©es [{concept, date, thread_id}]

    ChatService->>ConnectionManager: √âmet ws:concept_recall
    ConnectionManager->>User: Affiche badge/toast "Concept d√©j√† abord√© le..."

    ChatService->>ChatService: Injection contexte m√©moire enrichi dans prompt LLM
```

---

## 4. Impl√©mentation technique

### 4.1. Composant `ConceptRecallTracker`

**Fichier** : `src/backend/features/memory/concept_recall.py`

```python
# src/backend/features/memory/concept_recall.py
# V1.0 - Concept Recall Tracker for Emergence V8

import logging
import uuid
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timezone

from backend.core.database.manager import DatabaseManager
from backend.features.memory.vector_service import VectorService

logger = logging.getLogger(__name__)


class ConceptRecallTracker:
    """
    D√©tecte et trace les r√©currences conceptuelles dans l'historique utilisateur.

    Fonctionnalit√©s :
    - Recherche vectorielle sur concepts existants
    - Enrichissement m√©tadonn√©es (first_mentioned_at, mention_count, thread_ids)
    - √âmission √©v√©nements ws:concept_recall pour UI
    """

    COLLECTION_NAME = "emergence_knowledge"
    SIMILARITY_THRESHOLD = 0.75  # Seuil de d√©tection (cosine similarity)
    MAX_RECALLS_PER_MESSAGE = 3  # Limite de rappels par message pour √©viter spam

    def __init__(
        self,
        db_manager: DatabaseManager,
        vector_service: VectorService,
        connection_manager=None,
    ):
        self.db = db_manager
        self.vector_service = vector_service
        self.connection_manager = connection_manager
        self.collection = vector_service.get_or_create_collection(self.COLLECTION_NAME)

    async def detect_recurring_concepts(
        self,
        message_text: str,
        user_id: str,
        thread_id: str,
        message_id: str,
        session_id: str,
    ) -> List[Dict[str, Any]]:
        """
        D√©tecte si le message contient des concepts d√©j√† abord√©s.

        Returns:
            Liste de r√©currences : [
                {
                    "concept_text": "CI/CD pipeline",
                    "first_mentioned_at": "2025-10-02T14:32:00+00:00",
                    "last_mentioned_at": "2025-10-03T09:15:00+00:00",
                    "mention_count": 3,
                    "thread_ids": ["thread_xyz", "thread_abc"],
                    "similarity_score": 0.87,
                    "vector_id": "abc123"
                }
            ]
        """
        if not message_text or not user_id:
            return []

        try:
            # 1. Recherche vectorielle sur concepts existants de l'utilisateur
            results = self.vector_service.query(
                collection=self.collection,
                query_text=message_text,
                n_results=10,  # Top 10 concepts similaires
                where_filter={
                    "$and": [
                        {"user_id": user_id},
                        {"type": "concept"}
                    ]
                }
            )

            if not results:
                return []

            # 2. Filtrer par similarit√© et exclure thread actuel (√©viter auto-d√©tection)
            recalls = []
            for res in results:
                meta = res.get("metadata", {})
                score = res.get("score", 0.0)

                # Seuil de similarit√©
                if score < self.SIMILARITY_THRESHOLD:
                    continue

                # Exclure mentions du thread actuel (on cherche l'historique pass√©)
                thread_ids = meta.get("thread_ids", [])
                if len(thread_ids) == 1 and thread_ids[0] == thread_id:
                    continue  # Concept mentionn√© uniquement dans le thread actuel

                recall = {
                    "concept_text": meta.get("concept_text", ""),
                    "first_mentioned_at": meta.get("first_mentioned_at") or meta.get("created_at"),
                    "last_mentioned_at": meta.get("last_mentioned_at") or meta.get("created_at"),
                    "mention_count": meta.get("mention_count", 1),
                    "thread_ids": [tid for tid in thread_ids if tid != thread_id],  # Exclure thread actuel
                    "similarity_score": round(score, 4),
                    "vector_id": res.get("id", ""),
                }

                # Ne garder que si au moins un thread pass√© existe
                if recall["thread_ids"]:
                    recalls.append(recall)

                if len(recalls) >= self.MAX_RECALLS_PER_MESSAGE:
                    break

            # 3. Mettre √† jour les m√©tadonn√©es pour cette nouvelle mention
            if recalls:
                await self._update_mention_metadata(
                    recalls=recalls,
                    current_thread_id=thread_id,
                    current_message_id=message_id,
                    session_id=session_id,
                )

            # 4. √âmettre √©v√©nement WebSocket si r√©currences d√©tect√©es
            if recalls and self.connection_manager:
                await self._emit_concept_recall_event(
                    session_id=session_id,
                    recalls=recalls,
                )

            return recalls

        except Exception as e:
            logger.error(f"[ConceptRecallTracker] Erreur d√©tection r√©currences : {e}", exc_info=True)
            return []

    async def _update_mention_metadata(
        self,
        recalls: List[Dict[str, Any]],
        current_thread_id: str,
        current_message_id: str,
        session_id: str,
    ) -> None:
        """
        Met √† jour les m√©tadonn√©es vectorielles pour enregistrer la nouvelle mention.
        """
        now_iso = datetime.now(timezone.utc).isoformat()

        for recall in recalls:
            vector_id = recall.get("vector_id")
            if not vector_id:
                continue

            try:
                # R√©cup√©rer m√©tadonn√©es actuelles
                existing = self.collection.get(ids=[vector_id], include=["metadatas"])
                if not existing or not existing.get("metadatas"):
                    continue

                meta = existing["metadatas"][0] if isinstance(existing["metadatas"], list) else existing["metadatas"]

                # Incr√©menter mention_count
                mention_count = int(meta.get("mention_count", 1)) + 1

                # Ajouter thread_id si pas d√©j√† pr√©sent
                thread_ids = meta.get("thread_ids", [])
                if current_thread_id not in thread_ids:
                    thread_ids.append(current_thread_id)

                # Mettre √† jour
                updated_meta = dict(meta)
                updated_meta["mention_count"] = mention_count
                updated_meta["last_mentioned_at"] = now_iso
                updated_meta["thread_ids"] = thread_ids

                # Boost vitality (concept r√©utilis√© = plus pertinent)
                vitality = float(meta.get("vitality", 0.5))
                updated_meta["vitality"] = min(1.0, vitality + 0.1)

                self.vector_service.update_metadatas(
                    collection=self.collection,
                    ids=[vector_id],
                    metadatas=[updated_meta]
                )

                logger.debug(f"[ConceptRecallTracker] Concept {vector_id} mis √† jour : {mention_count} mentions")

            except Exception as e:
                logger.warning(f"[ConceptRecallTracker] Impossible de mettre √† jour {vector_id} : {e}")

    async def _emit_concept_recall_event(
        self,
        session_id: str,
        recalls: List[Dict[str, Any]],
    ) -> None:
        """
        √âmet un √©v√©nement WebSocket ws:concept_recall pour affichage UI.
        """
        if not self.connection_manager:
            return

        payload = {
            "variant": "concept_recall",
            "recalls": [
                {
                    "concept": r["concept_text"],
                    "first_date": r["first_mentioned_at"],
                    "last_date": r["last_mentioned_at"],
                    "count": r["mention_count"],
                    "thread_count": len(r["thread_ids"]),
                    "similarity": r["similarity_score"],
                }
                for r in recalls[:self.MAX_RECALLS_PER_MESSAGE]
            ]
        }

        try:
            await self.connection_manager.send_personal_message(
                {"type": "ws:concept_recall", "payload": payload},
                session_id
            )
            logger.info(f"[ConceptRecallTracker] √âv√©nement ws:concept_recall √©mis : {len(recalls)} r√©currences")
        except Exception as e:
            logger.debug(f"[ConceptRecallTracker] Impossible d'√©mettre ws:concept_recall : {e}")

    async def query_concept_history(
        self,
        concept_text: str,
        user_id: str,
        limit: int = 10,
    ) -> List[Dict[str, Any]]:
        """
        Recherche explicite d'un concept dans l'historique (pour requ√™te utilisateur).

        Usage:
            USER: "Est-ce qu'on a d√©j√† parl√© de containerisation ?"
            AGENT: appelle query_concept_history("containerisation", user_id)

        Returns:
            [
                {
                    "concept_text": "Docker containerisation",
                    "first_mentioned_at": "2025-09-28T10:15:00+00:00",
                    "thread_ids": ["thread_abc", "thread_def"],
                    "mention_count": 2,
                }
            ]
        """
        try:
            results = self.vector_service.query(
                collection=self.collection,
                query_text=concept_text,
                n_results=limit,
                where_filter={
                    "$and": [
                        {"user_id": user_id},
                        {"type": "concept"}
                    ]
                }
            )

            history = []
            for res in results:
                meta = res.get("metadata", {})
                if res.get("score", 0) >= 0.6:  # Seuil plus permissif pour requ√™te explicite
                    history.append({
                        "concept_text": meta.get("concept_text", ""),
                        "first_mentioned_at": meta.get("first_mentioned_at") or meta.get("created_at"),
                        "last_mentioned_at": meta.get("last_mentioned_at") or meta.get("created_at"),
                        "thread_ids": meta.get("thread_ids", []),
                        "mention_count": meta.get("mention_count", 1),
                        "similarity_score": round(res.get("score", 0), 4),
                    })

            return history

        except Exception as e:
            logger.error(f"[ConceptRecallTracker] Erreur query_concept_history : {e}", exc_info=True)
            return []
```

### 4.2. Int√©gration dans `MemoryGardener`

**Modifications** : [gardener.py:1476-1513](src/backend/features/memory/gardener.py#L1476)

Ajouter dans `_vectorize_concepts()` :

```python
async def _vectorize_concepts(
    self, concepts: List[str], session: Dict[str, Any], user_id: Optional[str]
):
    payload = []
    now_iso = _now_iso()

    # ‚Üê NOUVEAU : R√©cup√©rer thread_id et message_id depuis session/contexte
    thread_id = session.get("thread_id")  # Enrichir session stub si mode thread
    message_id = session.get("message_id")  # √Ä passer depuis ChatService

    for concept_text in concepts:
        vid = uuid.uuid4().hex
        payload.append(
            {
                "id": vid,
                "text": concept_text,
                "metadata": {
                    "type": "concept",
                    "user_id": user_id,
                    "source_session_id": session["id"],
                    "concept_text": concept_text,
                    "created_at": now_iso,
                    "first_mentioned_at": now_iso,  # ‚Üê NOUVEAU
                    "last_mentioned_at": now_iso,   # ‚Üê NOUVEAU
                    "thread_id": thread_id,         # ‚Üê NOUVEAU
                    "thread_ids": [thread_id] if thread_id else [],  # ‚Üê NOUVEAU
                    "message_id": message_id,       # ‚Üê NOUVEAU
                    "mention_count": 1,             # ‚Üê NOUVEAU
                    "last_access_at": now_iso,
                    "last_decay_at": now_iso,
                    "vitality": self.max_vitality,
                    "decay_runs": 0,
                    "usage_count": 0,
                },
            }
        )

    if payload:
        try:
            await asyncio.to_thread(
                self.vector_service.add_items, self.knowledge_collection, payload
            )
            logger.info(f"{len(payload)} concepts vectoris√©s avec m√©tadonn√©es enrichies.")
        except Exception as exc:
            logger.error(f"Vectorisation concepts √©chou√©e : {exc}", exc_info=True)
            raise
```

### 4.3. Int√©gration dans `ChatService`

**Point d'injection** : Apr√®s r√©ception du message utilisateur, avant appel LLM.

```python
# src/backend/features/chat/service.py (extrait)

from backend.features.memory.concept_recall import ConceptRecallTracker

class ChatService:
    def __init__(self, ...):
        # ... existing code ...
        self.concept_recall_tracker = ConceptRecallTracker(
            db_manager=db_manager,
            vector_service=vector_service,
            connection_manager=session_manager.connection_manager,
        )

    async def handle_chat_message(
        self,
        message: str,
        session_id: str,
        thread_id: str,
        user_id: str,
        agent_id: str = "neo",
        use_rag: bool = False,
        selected_doc_ids: List[int] = None,
    ):
        # ... existing validation ...

        # üÜï D√âTECTION CONCEPTS R√âCURRENTS
        message_id = uuid.uuid4().hex  # ID du message actuel
        recalls = await self.concept_recall_tracker.detect_recurring_concepts(
            message_text=message,
            user_id=user_id,
            thread_id=thread_id,
            message_id=message_id,
            session_id=session_id,
        )

        # üÜï ENRICHIR CONTEXTE M√âMOIRE AVEC R√âCURRENCES
        if recalls:
            recall_context = self._build_recall_context(recalls)
            # Injecter dans le prompt syst√®me ou message utilisateur enrichi
            # Ex: "[RECALL] Concepts d√©j√† abord√©s : CI/CD (2 oct 14:32, thread DevOps)..."

        # ... existing RAG + LLM logic ...

    def _build_recall_context(self, recalls: List[Dict[str, Any]]) -> str:
        """
        Construit un bloc de contexte pour informer le LLM des r√©currences.
        """
        lines = ["[RECALL] Concepts d√©j√† abord√©s par l'utilisateur :"]
        for r in recalls:
            concept = r["concept_text"]
            first_date = r["first_mentioned_at"][:16]  # 2025-10-02T14:32
            count = r["mention_count"]
            threads = len(r["thread_ids"])
            lines.append(f"- {concept} (premi√®re mention : {first_date}, {count} fois, {threads} threads)")
        return "\n".join(lines)
```

---

## 5. Contrats API & √©v√©nements

### 5.1. √âv√©nement WebSocket : `ws:concept_recall`

**Direction** : Backend ‚Üí Frontend
**Trigger** : D√©tection automatique pendant `ChatService.handle_chat_message`

**Payload** :

```typescript
{
  "type": "ws:concept_recall",
  "payload": {
    "variant": "concept_recall",
    "recalls": [
      {
        "concept": "CI/CD pipeline",
        "first_date": "2025-10-02T14:32:00+00:00",
        "last_date": "2025-10-03T09:15:00+00:00",
        "count": 3,                 // Nombre total de mentions
        "thread_count": 2,          // Nombre de threads concern√©s
        "similarity": 0.87          // Score de similarit√© s√©mantique
      }
    ]
  }
}
```

**Rendu UI** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üîó Concept d√©j√† abord√©                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ CI/CD pipeline                                          ‚îÇ
‚îÇ ‚Ä¢ Premi√®re mention : 2 oct 2025, 14:32                 ‚îÇ
‚îÇ ‚Ä¢ Mentionn√© 3 fois dans 2 threads                      ‚îÇ
‚îÇ ‚Ä¢ Similarit√© : 87%                                      ‚îÇ
‚îÇ [Voir l'historique] [Ignorer]                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5.2. Endpoint REST : `GET /api/memory/concepts/search`

**Usage** : Recherche explicite d'un concept par l'utilisateur.

**Request** :

```http
GET /api/memory/concepts/search?q=containerisation&limit=5
Authorization: Bearer <JWT>
X-Session-Id: <session_id>
```

**Response** :

```json
{
  "query": "containerisation",
  "results": [
    {
      "concept_text": "Docker containerisation",
      "first_mentioned_at": "2025-09-28T10:15:00+00:00",
      "last_mentioned_at": "2025-10-01T16:42:00+00:00",
      "thread_ids": ["thread_abc", "thread_def"],
      "mention_count": 2,
      "similarity_score": 0.92
    },
    {
      "concept_text": "Kubernetes orchestration",
      "first_mentioned_at": "2025-09-28T10:30:00+00:00",
      "last_mentioned_at": "2025-09-28T10:30:00+00:00",
      "thread_ids": ["thread_abc"],
      "mention_count": 1,
      "similarity_score": 0.78
    }
  ]
}
```

**Impl√©mentation** :

```python
# src/backend/features/memory/router.py

@router.get("/concepts/search")
async def search_concepts(
    q: str = Query(..., min_length=3),
    limit: int = Query(10, ge=1, le=50),
    user_id: str = Depends(get_user_id),
    session_id: str = Header(None, alias="X-Session-Id"),
):
    """
    Recherche de concepts dans l'historique utilisateur.
    """
    tracker: ConceptRecallTracker = container.concept_recall_tracker()

    results = await tracker.query_concept_history(
        concept_text=q,
        user_id=user_id,
        limit=limit,
    )

    return {
        "query": q,
        "results": results,
    }
```

### 5.3. Endpoint REST : `GET /api/memory/concepts/{concept_id}/mentions`

**Usage** : R√©cup√©rer toutes les mentions d'un concept sp√©cifique avec contexte.

**Request** :

```http
GET /api/memory/concepts/abc123/mentions
Authorization: Bearer <JWT>
```

**Response** :

```json
{
  "concept_id": "abc123",
  "concept_text": "CI/CD pipeline",
  "mention_count": 3,
  "mentions": [
    {
      "thread_id": "thread_xyz",
      "thread_title": "Infrastructure DevOps",
      "message_id": "msg_789",
      "mentioned_at": "2025-10-02T14:32:00+00:00",
      "context_snippet": "...automatiser le d√©ploiement avec une CI/CD pipeline robuste...",
      "similarity_score": 1.0
    },
    {
      "thread_id": "thread_abc",
      "thread_title": "D√©bat architecture",
      "message_id": "msg_456",
      "mentioned_at": "2025-10-03T09:15:00+00:00",
      "context_snippet": "...int√©grer la CI/CD dans notre workflow microservices...",
      "similarity_score": 0.95
    }
  ]
}
```

**Note** : N√©cessite la table `concept_mentions` (optionnel). Si non impl√©ment√©e, retourner seulement les m√©tadonn√©es du vecteur.

---

## 6. Plan de d√©ploiement

### 6.1. Phase 1 : Infrastructure de base (Sprint 1)

**Objectif** : Enrichir les m√©tadonn√©es vectorielles existantes sans changement UX.

- [ ] Modifier `MemoryGardener._vectorize_concepts()` pour ajouter :
  - `first_mentioned_at`
  - `last_mentioned_at`
  - `thread_id`, `thread_ids[]`
  - `message_id`
  - `mention_count`

- [ ] Migration des donn√©es existantes :
  - Script Python pour it√©rer sur `emergence_knowledge`
  - Remplir `first_mentioned_at` avec `created_at` actuel
  - Initialiser `mention_count = 1`, `thread_ids = []`

- [ ] Tests unitaires :
  - `tests/backend/features/test_memory_gardener_enrichment.py`
  - V√©rifier que nouveaux concepts ont toutes les m√©tadonn√©es
  - V√©rifier que migration n'a pas cass√© la recherche vectorielle

### 6.2. Phase 2 : D√©tection passive (Sprint 2)

**Objectif** : `ConceptRecallTracker` op√©rationnel, logs uniquement (pas d'√©v√©nements UI).

- [ ] Impl√©menter `ConceptRecallTracker` complet ([concept_recall.py](#41-composant-conceptrecalltracker))

- [ ] Int√©grer dans `ChatService.handle_chat_message()` :
  - Appel `detect_recurring_concepts()` avant LLM
  - Logger les r√©currences d√©tect√©es (niveau INFO)
  - **NE PAS** √©mettre `ws:concept_recall` (flag `emit_events=False`)

- [ ] Monitoring :
  - Ajouter m√©triques Prometheus : `concept_recalls_detected_total`, `concept_recall_latency_ms`
  - Dashboard Grafana : tendances de r√©currence par utilisateur

- [ ] Tests :
  - `tests/backend/features/test_concept_recall_tracker.py`
  - Sc√©nario : 2 messages similaires ‚Üí d√©tection de r√©currence
  - Sc√©nario : Mise √† jour `mention_count` et `thread_ids`

### 6.3. Phase 3 : √âv√©nements WebSocket (Sprint 3)

**Objectif** : Affichage UI des r√©currences d√©tect√©es.

- [ ] Activer √©mission `ws:concept_recall` dans `ConceptRecallTracker`

- [ ] Frontend :
  - `src/frontend/features/chat/concept-recall-banner.js`
  - √âcouter √©v√©nement `EventBus.on('ws:concept_recall')`
  - Afficher toast/banner avec bouton "Voir l'historique"

- [ ] Tests frontend :
  - `src/frontend/features/chat/__tests__/concept-recall.test.js`
  - Simuler √©v√©nement WS, v√©rifier affichage du banner

### 6.4. Phase 4 : API de recherche explicite (Sprint 4)

**Objectif** : Permettre √† l'utilisateur de demander "on a d√©j√† parl√© de X ?".

- [ ] Endpoint `GET /api/memory/concepts/search` ([5.2](#52-endpoint-rest-get-apimemoryconceptssearch))

- [ ] Prompt syst√®me pour LLM :
  ```
  Si l'utilisateur demande "on a d√©j√† parl√© de X ?", appelle l'API
  /api/memory/concepts/search?q=X et r√©sume les r√©sultats.
  ```

- [ ] Tests :
  - `tests/backend/features/test_memory_concept_search.py`
  - Requ√™te valide ‚Üí r√©sultats tri√©s par similarit√©
  - Requ√™te vide ‚Üí 400 Bad Request

### 6.5. Phase 5 : Clustering et d√©duplication (Future)

**Objectif** : D√©tecter les concepts synonymes/reformulations.

- [ ] Clustering s√©mantique :
  - Regrouper "CI/CD", "pipeline automatique", "int√©gration continue" sous un m√™me cluster
  - Utiliser HDBSCAN ou K-means sur embeddings

- [ ] UI d'administration :
  - Tableau des clusters d√©tect√©s
  - Merge manuel de concepts similaires

---

## 7. Tests & validation

### 7.1. Tests unitaires

**Fichier** : `tests/backend/features/test_concept_recall_tracker.py`

```python
import pytest
from backend.features.memory.concept_recall import ConceptRecallTracker

@pytest.mark.asyncio
async def test_detect_recurring_concepts_first_mention(db_manager, vector_service):
    tracker = ConceptRecallTracker(db_manager, vector_service)

    # Premier message : aucun concept existant
    recalls = await tracker.detect_recurring_concepts(
        message_text="Je veux setup une CI/CD",
        user_id="user_123",
        thread_id="thread_abc",
        message_id="msg_001",
        session_id="session_xyz",
    )

    assert recalls == []  # Pas de r√©currence d√©tect√©e

@pytest.mark.asyncio
async def test_detect_recurring_concepts_second_mention(db_manager, vector_service, seed_concept):
    # Pr√©-remplir un concept "CI/CD pipeline" dans le vector store
    await seed_concept(
        concept_text="CI/CD pipeline",
        user_id="user_123",
        thread_id="thread_old",
        first_mentioned_at="2025-10-02T14:32:00+00:00",
    )

    tracker = ConceptRecallTracker(db_manager, vector_service)

    recalls = await tracker.detect_recurring_concepts(
        message_text="Comment am√©liorer notre pipeline CI/CD ?",
        user_id="user_123",
        thread_id="thread_new",
        message_id="msg_002",
        session_id="session_xyz",
    )

    assert len(recalls) == 1
    assert recalls[0]["concept_text"] == "CI/CD pipeline"
    assert recalls[0]["mention_count"] == 2  # Incr√©ment√©
    assert "thread_old" in recalls[0]["thread_ids"]
    assert recalls[0]["similarity_score"] > 0.75

@pytest.mark.asyncio
async def test_update_mention_metadata(db_manager, vector_service, seed_concept):
    vector_id = await seed_concept(
        concept_text="Docker",
        user_id="user_123",
        thread_id="thread_1",
        mention_count=1,
    )

    tracker = ConceptRecallTracker(db_manager, vector_service)

    await tracker._update_mention_metadata(
        recalls=[{"vector_id": vector_id, "concept_text": "Docker"}],
        current_thread_id="thread_2",
        current_message_id="msg_003",
        session_id="session_xyz",
    )

    # V√©rifier m√©tadonn√©es mises √† jour
    collection = vector_service.get_or_create_collection("emergence_knowledge")
    result = collection.get(ids=[vector_id], include=["metadatas"])
    meta = result["metadatas"][0]

    assert meta["mention_count"] == 2
    assert "thread_2" in meta["thread_ids"]
    assert meta["last_mentioned_at"] is not None
```

### 7.2. Tests d'int√©gration

**Fichier** : `tests/test_concept_recall_integration.ps1`

```powershell
# tests/test_concept_recall_integration.ps1
# Sc√©nario complet : 2 threads, d√©tection r√©currence

param(
    [string]$BaseUrl = "http://127.0.0.1:8000"
)

. "$PSScriptRoot/helpers/auth.ps1"

$session = Get-AuthSession -Email $env:EMERGENCE_SMOKE_EMAIL -Password $env:EMERGENCE_SMOKE_PASSWORD

# √âtape 1 : Cr√©er un premier thread et mentionner "containerisation"
$thread1 = Invoke-RestMethod -Uri "$BaseUrl/api/threads" -Method POST `
    -Headers @{
        "Authorization" = "Bearer $($session.token)"
        "X-Session-Id" = $session.session_id
    } `
    -ContentType "application/json" `
    -Body '{"title":"Docker Setup"}'

# Envoyer un message dans thread1
Invoke-RestMethod -Uri "$BaseUrl/api/threads/$($thread1.id)/messages" -Method POST `
    -Headers @{
        "Authorization" = "Bearer $($session.token)"
        "X-Session-Id" = $session.session_id
    } `
    -ContentType "application/json" `
    -Body '{"content":"Je veux containeriser mon app avec Docker"}'

# Attendre consolidation m√©moire
Start-Sleep -Seconds 5
Invoke-RestMethod -Uri "$BaseUrl/api/memory/tend-garden" -Method POST `
    -Headers @{
        "Authorization" = "Bearer $($session.token)"
        "X-Session-Id" = $session.session_id
    } `
    -ContentType "application/json" `
    -Body '{}'

# √âtape 2 : Cr√©er un second thread et re-mentionner "containerisation"
$thread2 = Invoke-RestMethod -Uri "$BaseUrl/api/threads" -Method POST `
    -Headers @{
        "Authorization" = "Bearer $($session.token)"
        "X-Session-Id" = $session.session_id
    } `
    -ContentType "application/json" `
    -Body '{"title":"Kubernetes Migration"}'

# Envoyer message dans thread2 ‚Üí devrait d√©clencher ws:concept_recall
Invoke-RestMethod -Uri "$BaseUrl/api/threads/$($thread2.id)/messages" -Method POST `
    -Headers @{
        "Authorization" = "Bearer $($session.token)"
        "X-Session-Id" = $session.session_id
    } `
    -ContentType "application/json" `
    -Body '{"content":"Comment migrer mes containers Docker vers Kubernetes ?"}'

# √âtape 3 : Rechercher le concept via API
$search = Invoke-RestMethod -Uri "$BaseUrl/api/memory/concepts/search?q=containerisation" `
    -Headers @{
        "Authorization" = "Bearer $($session.token)"
        "X-Session-Id" = $session.session_id
    }

Write-Host "=== R√©sultats recherche concept ===" -ForegroundColor Cyan
$search.results | ConvertTo-Json -Depth 5

if ($search.results.Count -ge 1) {
    Write-Host "‚úÖ Concept d√©tect√© : $($search.results[0].concept_text)" -ForegroundColor Green
    Write-Host "   Mentionn√© $($search.results[0].mention_count) fois dans $($search.results[0].thread_ids.Count) threads"
} else {
    Write-Host "‚ùå Aucun concept d√©tect√©" -ForegroundColor Red
    exit 1
}
```

### 7.3. QA manuelle

**Checklist** :

- [ ] **Sc√©nario 1** : Cr√©er thread "DevOps", mentionner "CI/CD" ‚Üí consolider ‚Üí cr√©er nouveau thread "Automation" ‚Üí re-mentionner "pipeline CI/CD" ‚Üí v√©rifier toast/banner UI avec date pr√©cise.

- [ ] **Sc√©nario 2** : Demander explicitement "on a d√©j√† parl√© de Docker ?" ‚Üí v√©rifier que l'agent appelle `/api/memory/concepts/search` et liste les occurrences avec threads.

- [ ] **Sc√©nario 3** : Mentionner le m√™me concept 5 fois dans le m√™me thread ‚Üí v√©rifier que `mention_count` s'incr√©mente mais que `thread_ids` reste √† 1 seul thread.

- [ ] **Sc√©nario 4** : V√©rifier que les concepts tr√®s anciens (>45j) sont bien supprim√©s par le decay ‚Üí pas de faux positifs.

---

## 8. Checklist de livraison

### 8.1. Backend

- [ ] Fichier `src/backend/features/memory/concept_recall.py` cr√©√© et test√©
- [ ] M√©tadonn√©es enrichies dans `MemoryGardener._vectorize_concepts()`
- [ ] Int√©gration dans `ChatService.handle_chat_message()`
- [ ] Endpoint `GET /api/memory/concepts/search` fonctionnel
- [ ] Migration donn√©es existantes (script `scripts/migrate_concept_metadata.py`)
- [ ] Tests unitaires `tests/backend/features/test_concept_recall_tracker.py` (couverture ‚â•80%)
- [ ] Tests d'int√©gration `tests/test_concept_recall_integration.ps1` (smoke pass)

### 8.2. Frontend

- [ ] Module `src/frontend/features/chat/concept-recall-banner.js`
- [ ] √âcoute √©v√©nement `ws:concept_recall` dans EventBus
- [ ] UI toast/banner avec design coh√©rent (dark mode support√©)
- [ ] Bouton "Voir l'historique" (ouvre modal avec timeline des mentions)
- [ ] Tests frontend `src/frontend/features/chat/__tests__/concept-recall.test.js`

### 8.3. Documentation

- [ ] Ce document (`docs/architecture/CONCEPT_RECALL.md`) valid√© par FG
- [ ] Mise √† jour [docs/Memoire.md](docs/Memoire.md) section 3.Flux (ajout flux 9 : D√©tection concepts r√©currents)
- [ ] Mise √† jour [docs/architecture/30-Contracts.md](docs/architecture/30-Contracts.md) (√©v√©nement `ws:concept_recall`)
- [ ] Guide utilisateur : "Comment activer/d√©sactiver les rappels de concepts" (si toggle UI ajout√©)

### 8.4. D√©ploiement

- [ ] Variables d'environnement :
  - `CONCEPT_RECALL_ENABLED` (bool, default: true)
  - `CONCEPT_RECALL_THRESHOLD` (float, default: 0.75)
  - `CONCEPT_RECALL_MAX_PER_MESSAGE` (int, default: 3)

- [ ] Smoke tests prod :
  - `scripts/smoke/smoke-concept-recall.ps1 -BaseUrl https://emergence-app-xxx.run.app`

- [ ] Monitoring Grafana :
  - Dashboard "Concept Recall" avec m√©triques :
    - Taux de d√©tection par jour
    - Latence moyenne `concept_recall_latency_ms`
    - Top 10 concepts r√©currents

### 8.5. Passation

- [ ] Entr√©e dans [docs/passation.md](docs/passation.md) :
  - Date/heure session
  - Fichiers modifi√©s
  - Tests ex√©cut√©s
  - Actions recommand√©es pour Codex (UI banner, tests frontend)
  - Blocages √©ventuels

---

## 9. Exemples d'usage

### 9.1. Cas nominal : D√©tection automatique

**Timeline** :

1. **2 oct 2025, 14:32** ‚Äî Thread "Infrastructure DevOps"
   ```
   USER: Comment automatiser le d√©ploiement avec une CI/CD pipeline ?
   AGENT: [R√©pond normalement]
   ‚Üí Backend : Vectorise concept "CI/CD pipeline" (mention_count=1, thread_ids=["thread_xyz"])
   ```

2. **4 oct 2025, 09:20** ‚Äî Thread "Projet Mobile"
   ```
   USER: Je veux setup une pipeline CI/CD pour mon app React Native

   ‚Üí Backend d√©tecte r√©currence (similarit√© 0.87)
   ‚Üí √âmet ws:concept_recall

   UI affiche :
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ üîó Nous avons d√©j√† abord√© ce sujet              ‚îÇ
   ‚îÇ CI/CD pipeline ‚Äî 2 oct 2025, 14:32             ‚îÇ
   ‚îÇ Mentionn√© 1 fois dans 1 autre thread           ‚îÇ
   ‚îÇ [Reprendre les conclusions] [Continuer]        ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

   AGENT: Je vois que nous avons d√©j√† explor√© la CI/CD le 2 octobre.
          Souhaitez-vous que je m'appuie sur cette base pour adapter
          la solution √† React Native, ou pr√©f√©rez-vous repartir de z√©ro ?
   ```

### 9.2. Requ√™te explicite utilisateur

```
USER: Est-ce qu'on a d√©j√† parl√© de containerisation ?

AGENT: [Appelle GET /api/memory/concepts/search?q=containerisation]

‚Üí R√©sultats : 2 concepts similaires

AGENT: Oui, nous avons abord√© la containerisation √† plusieurs reprises :

       1. Docker containerisation
          ‚Ä¢ Premi√®re mention : 28 sept 2025, 10:15
          ‚Ä¢ Thread : "Migration Docker"
          ‚Ä¢ Concepts associ√©s : microservices, orchestration

       2. Kubernetes containerisation
          ‚Ä¢ Premi√®re mention : 1 oct 2025, 16:42
          ‚Ä¢ Thread : "D√©bat architecture cloud"
          ‚Ä¢ Concepts associ√©s : scalabilit√©, haute disponibilit√©

       Souhaitez-vous que je reprenne l'un de ces sujets ?
```

### 9.3. D√©tection redondance (√©viter r√©p√©titions)

```
USER: Parle-moi de l'optimisation m√©moire en Python

‚Üí Backend d√©tecte que ce sujet a √©t√© abord√© 3 fois dans les 2 derni√®res semaines

UI affiche toast warning :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚ö†Ô∏è  Sujet r√©current d√©tect√©                           ‚îÇ
‚îÇ "Optimisation m√©moire Python" a √©t√© abord√© 3 fois    ‚îÇ
‚îÇ depuis le 15 sept 2025.                               ‚îÇ
‚îÇ [Voir historique complet] [Ignorer]                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

AGENT: Je remarque que nous revenons r√©guli√®rement sur l'optimisation
       m√©moire Python (3 fois ce mois-ci). Pour √©viter de r√©p√©ter,
       voici les conclusions pr√©c√©dentes :

       - 15 sept : Utilisation de __slots__ pour classes data
       - 22 sept : Profilage avec memory_profiler
       - 29 sept : Optimisation structures numpy

       Y a-t-il un aspect sp√©cifique que nous n'avons pas encore couvert ?
```

---

## 10. Risques & mitigations

### 10.1. Risques identifi√©s

| Risque | Impact | Probabilit√© | Mitigation |
|--------|--------|-------------|------------|
| **Latence d√©tection** : Recherche vectorielle ralentit le flux chat | Moyen | Faible | - Timeout 500ms sur `detect_recurring_concepts()`<br>- Mise en cache des r√©sultats vectoriels (TTL 5min)<br>- Flag `CONCEPT_RECALL_ENABLED=false` pour d√©sactiver |
| **Faux positifs** : Concepts non pertinents d√©tect√©s (homonymes) | Moyen | Moyenne | - Seuil de similarit√© √©lev√© (0.75)<br>- Filtrage par `user_id` strict<br>- Clustering s√©mantique (Phase 5) |
| **Spam UI** : Trop de toasts/banners si beaucoup de r√©currences | Faible | Moyenne | - Limite `MAX_RECALLS_PER_MESSAGE = 3`<br>- Toggle utilisateur "D√©sactiver rappels concepts"<br>- Cooldown 1 rappel / concept / 24h |
| **Migration donn√©es** : M√©tadonn√©es manquantes pour concepts existants | Moyen | Faible | - Script de migration avec fallback : `first_mentioned_at = created_at`<br>- Logs d√©taill√©s pour tracer √©checs migration |
| **Croissance m√©tadonn√©es** : `thread_ids[]` devient tr√®s long (>100 threads) | Faible | Faible | - Limiter √† 50 threads max (FIFO : supprimer les plus anciens)<br>- Archivage dans table SQL si besoin |

### 10.2. Rollback plan

**Si d√©tection bugue en production** :

1. **D√©sactivation imm√©diate** : `export CONCEPT_RECALL_ENABLED=false` + red√©marrage backend
2. **Rollback code** : `git revert <commit_concept_recall>` + red√©ploiement
3. **Donn√©es** : M√©tadonn√©es enrichies n'impactent pas les fonctionnalit√©s existantes ‚Üí pas de rollback DB n√©cessaire

---

## 11. Prochaines √©tapes (apr√®s validation)

1. **Validation architecte (FG)** :
   - Revue de ce document
   - Approbation sch√©ma m√©tadonn√©es enrichies
   - Validation priorit√©s (Phases 1-4 vs Phase 5)

2. **Estimation effort** :
   - Phase 1 : 2j (enrichissement m√©tadonn√©es + migration)
   - Phase 2 : 3j (ConceptRecallTracker + int√©gration ChatService)
   - Phase 3 : 2j (√©v√©nements WS + UI frontend)
   - Phase 4 : 2j (API search + prompts LLM)
   - **Total** : ~9 jours-dev (~2 sprints)

3. **Assignation** :
   - **Claude Code (backend)** : Phases 1, 2, 4
   - **Codex (frontend + scripts)** : Phase 3, scripts smoke tests
   - **FG (validation)** : Review PRs, QA manuelle

4. **Kickoff** : Cr√©er branche `feat/concept-recall-tracker` et initialiser structure fichiers.

---

**Fin du document.**
Pour toute question ou modification, contacter l'architecte (FG) avant impl√©mentation.
