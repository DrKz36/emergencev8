"""
Proactive Hints Engine - Sprint 2 P2

Generates contextual suggestions based on user preferences and conversation patterns.

Features:
- Track concept recurrence (trigger hints on repeated mentions)
- Match preferences with current context
- Score hint relevance
- Emit hints via WebSocket (ws:proactive_hint)

Usage:
    engine = ProactiveHintEngine(vector_service, db_manager)
    hints = await engine.generate_hints(user_id, current_context)
"""

from __future__ import annotations
import logging
import hashlib
import asyncio
from typing import Any, Dict, List, Optional
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

# Prometheus metrics
try:
    from prometheus_client import Counter, Histogram

    PROMETHEUS_AVAILABLE = True

    proactive_hints_generated = Counter(
        "memory_proactive_hints_generated_total",
        "Proactive hints generated by type",
        ["type"],  # preference_reminder | intent_followup | constraint_warning
    )

    proactive_hints_relevance = Histogram(
        "memory_proactive_hints_relevance_score",
        "Relevance scores of generated hints",
        buckets=[0.0, 0.3, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
    )
except ImportError:
    PROMETHEUS_AVAILABLE = False
    logger.debug("[ProactiveHintEngine] Prometheus client unavailable")


@dataclass
class ProactiveHint:
    """Structured hint for proactive suggestions."""

    id: str
    type: str  # "preference_reminder" | "intent_followup" | "constraint_warning"
    title: str
    message: str
    relevance_score: float
    source_preference_id: Optional[str] = None
    action_label: Optional[str] = None
    action_payload: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict for JSON serialization."""
        return asdict(self)


class ConceptTracker:
    """Track concept mentions and trigger hints on recurrence."""

    def __init__(self):
        self._concept_counters: Dict[str, int] = {}  # {user_id:concept: count}
        self._last_reset: Dict[str, datetime] = {}  # {user_id:concept: timestamp}
        self._reset_window = timedelta(hours=24)  # Reset counters after 24h
        # ðŸ”’ Lock pour accÃ¨s concurrent aux compteurs (Bug #3 fix)
        self._counter_lock = asyncio.Lock()

    async def track_mention(self, user_id: str, concept: str) -> int:
        """
        Track concept mention and return current count (thread-safe).

        Auto-resets counter after 24h of inactivity.

        Args:
            user_id: User identifier
            concept: Concept mentioned

        Returns:
            Current count for this concept (after increment)
        """
        async with self._counter_lock:
            key = f"{user_id}:{concept}"
            now = datetime.now()

            # Check if counter needs reset (24h expired)
            last_reset = self._last_reset.get(key)
            if last_reset and (now - last_reset) > self._reset_window:
                self._concept_counters[key] = 0
                logger.debug(f"[ConceptTracker] Reset counter for {key} (24h expired)")

            # Increment counter
            self._concept_counters[key] = self._concept_counters.get(key, 0) + 1
            self._last_reset[key] = now

            count = self._concept_counters[key]
            logger.debug(f"[ConceptTracker] {key} mentioned {count} times")

            return count

    async def reset_counter(self, user_id: str, concept: str) -> None:
        """Reset counter for specific concept (after hint emitted) - thread-safe."""
        async with self._counter_lock:
            key = f"{user_id}:{concept}"
            self._concept_counters[key] = 0
            self._last_reset[key] = datetime.now()
            logger.debug(f"[ConceptTracker] Counter reset for {key}")


class ProactiveHintEngine:
    """
    Generate proactive hints based on user preferences and context.

    Strategies:
    1. Preference reminder: Suggest when repeated concept matches preference
    2. Intent followup: Remind about uncompleted intentions
    3. Constraint warning: Alert when violating constraints
    """

    def __init__(self, vector_service, db_manager=None):
        """
        Initialize ProactiveHintEngine.

        Args:
            vector_service: VectorService instance for ChromaDB queries
            db_manager: Optional DatabaseManager for session queries
        """
        self.vector_service = vector_service
        self.db = db_manager
        self.concept_tracker = ConceptTracker()

        # Configuration
        self.max_hints_per_call = 3  # Max hints returned per generate_hints() call
        self.recurrence_threshold = 3  # Trigger hint after 3 mentions
        self.min_relevance_score = 0.6  # Min score to emit hint

        logger.info(
            "[ProactiveHintEngine] Initialized (max_hints=3, recurrence_threshold=3)"
        )

    async def generate_hints(
        self, user_id: str, current_context: Dict[str, Any]
    ) -> List[ProactiveHint]:
        """
        Generate proactive hints based on current context.

        Args:
            user_id: User identifier
            current_context: Dict with keys:
                - topic: Current conversation topic (str)
                - message: Last user message (str)
                - agent: Current agent ID (optional)
                - conversation_context: List of recent messages (optional)

        Returns:
            List of ProactiveHint objects (max 3, sorted by relevance)
        """
        if not user_id:
            logger.warning(
                "[ProactiveHintEngine] generate_hints called without user_id"
            )
            return []

        hints: List[ProactiveHint] = []

        try:
            # Extract concepts from current message
            topic = current_context.get("topic", "")
            message = current_context.get("message", "")

            # Simple concept extraction (can be enhanced with NLP)
            concepts = self._extract_concepts_simple(message or topic)

            # Strategy 1: Check concept recurrence â†’ preference reminders
            for concept in concepts[:5]:  # Limit to top 5 concepts
                count = await self.concept_tracker.track_mention(user_id, concept)

                if count >= self.recurrence_threshold:
                    # Fetch related preferences
                    related_prefs = await self._fetch_related_preferences(
                        user_id, concept
                    )

                    if related_prefs:
                        hint = self._create_preference_reminder_hint(
                            concept=concept, preferences=related_prefs, count=count
                        )

                        if hint and hint.relevance_score >= self.min_relevance_score:
                            hints.append(hint)
                            await self.concept_tracker.reset_counter(user_id, concept)

                            # Metrics
                            if PROMETHEUS_AVAILABLE:
                                proactive_hints_generated.labels(
                                    type="preference_reminder"
                                ).inc()
                                proactive_hints_relevance.observe(hint.relevance_score)

            # Strategy 2: Intent followup (check for uncompleted intentions)
            intent_hints = await self._check_intent_followup(user_id, current_context)
            hints.extend(intent_hints)

            # Sort by relevance and limit
            hints.sort(key=lambda h: h.relevance_score, reverse=True)
            top_hints = hints[: self.max_hints_per_call]

            if top_hints:
                logger.info(
                    f"[ProactiveHintEngine] Generated {len(top_hints)} hints for user {user_id[:8]}"
                )

            return top_hints

        except Exception as e:
            logger.error(
                f"[ProactiveHintEngine] Failed to generate hints: {e}", exc_info=True
            )
            return []

    def _extract_concepts_simple(self, text: str) -> List[str]:
        """
        Simple concept extraction (keywords > 4 chars).

        Can be enhanced with NLP (spaCy, NLTK) in future.

        Args:
            text: Input text

        Returns:
            List of concepts (lowercase, deduplicated)
        """
        if not text:
            return []

        # Simple tokenization: split on spaces, filter length
        words = text.lower().split()
        concepts = [
            w.strip(".,!?;:\"'()[]{}")
            for w in words
            if len(w) > 4  # Min 5 chars
        ]

        # Deduplicate while preserving order
        seen = set()
        unique_concepts = []
        for c in concepts:
            if c not in seen:
                seen.add(c)
                unique_concepts.append(c)

        return unique_concepts[:10]  # Max 10 concepts

    async def _fetch_related_preferences(
        self, user_id: str, concept: str
    ) -> List[Dict[str, Any]]:
        """
        Fetch preferences related to concept via vector search.

        Args:
            user_id: User identifier
            concept: Concept to search

        Returns:
            List of preference records (metadata + text)
        """
        try:
            collection = self.vector_service.get_or_create_collection(
                "emergence_knowledge"
            )

            # Vector search for preferences matching concept
            results = self.vector_service.query(
                collection=collection,
                query_text=concept,
                n_results=3,  # Top 3 related preferences
                where_filter={
                    "$and": [
                        {"user_id": user_id},
                        {"type": "preference"},
                        {"confidence": {"$gte": 0.6}},  # High confidence only
                    ]
                },
            )

            preferences = []
            for r in results:
                preferences.append(
                    {
                        "id": r.get("id"),
                        "text": r.get("text"),
                        "metadata": r.get("metadata", {}),
                        "distance": r.get("distance", 1.0),
                    }
                )

            logger.debug(
                f"[ProactiveHintEngine] Found {len(preferences)} preferences for concept '{concept}'"
            )

            return preferences

        except Exception as e:
            logger.error(
                f"[ProactiveHintEngine] Failed to fetch preferences for '{concept}': {e}",
                exc_info=True,
            )
            return []

    def _create_preference_reminder_hint(
        self, concept: str, preferences: List[Dict[str, Any]], count: int
    ) -> Optional[ProactiveHint]:
        """
        Create preference reminder hint.

        Args:
            concept: Recurring concept
            preferences: Related preferences
            count: Number of mentions

        Returns:
            ProactiveHint or None
        """
        if not preferences:
            return None

        top_pref = preferences[0]
        pref_text = top_pref.get("text", "")
        distance = top_pref.get("distance", 1.0)

        # Calculate relevance score (based on vector distance)
        # Lower distance = higher relevance
        relevance_score = max(0.0, 1.0 - distance)

        # Generate hint ID (deterministic hash)
        hint_id = hashlib.md5(
            f"pref_reminder:{concept}:{pref_text}".encode()
        ).hexdigest()[:16]

        hint = ProactiveHint(
            id=hint_id,
            type="preference_reminder",
            title="Rappel: PrÃ©fÃ©rence dÃ©tectÃ©e",
            message=(
                f"ðŸ’¡ Tu as mentionnÃ© '{concept}' {count} fois. "
                f"Rappel de ta prÃ©fÃ©rence: {pref_text}"
            ),
            relevance_score=relevance_score,
            source_preference_id=top_pref.get("id"),
            action_label="Appliquer",
            action_payload={"preference": pref_text, "concept": concept},
        )

        return hint

    async def _check_intent_followup(
        self, user_id: str, current_context: Dict[str, Any]
    ) -> List[ProactiveHint]:
        """
        Check for uncompleted intentions and suggest followup.

        Args:
            user_id: User identifier
            current_context: Current conversation context

        Returns:
            List of intent followup hints
        """
        hints = []

        try:
            collection = self.vector_service.get_or_create_collection(
                "emergence_knowledge"
            )

            # Search for recent intentions (type="intent")
            results = self.vector_service.query(
                collection=collection,
                query_text=current_context.get("message", ""),
                n_results=2,
                where_filter={"$and": [{"user_id": user_id}, {"type": "intent"}]},
            )

            for r in results:
                intent_text = r.get("text", "")
                distance = r.get("distance", 1.0)
                relevance_score = max(0.0, 1.0 - distance)

                if relevance_score >= self.min_relevance_score:
                    hint_id = hashlib.md5(
                        f"intent_followup:{intent_text}".encode()
                    ).hexdigest()[:16]

                    hint = ProactiveHint(
                        id=hint_id,
                        type="intent_followup",
                        title="Intention dÃ©tectÃ©e",
                        message=f"ðŸŽ¯ Rappel: {intent_text}. As-tu avancÃ© dessus?",
                        relevance_score=relevance_score,
                        source_preference_id=r.get("id"),
                        action_label="Oui, c'est fait",
                        action_payload={"intent": intent_text},
                    )

                    hints.append(hint)

                    # Metrics
                    if PROMETHEUS_AVAILABLE:
                        proactive_hints_generated.labels(type="intent_followup").inc()
                        proactive_hints_relevance.observe(relevance_score)

        except Exception as e:
            logger.error(
                f"[ProactiveHintEngine] Failed to check intent followup: {e}",
                exc_info=True,
            )

        return hints
