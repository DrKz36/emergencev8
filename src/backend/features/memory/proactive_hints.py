"""
Proactive Hints Engine - Sprint 2 P2

Generates contextual suggestions based on user preferences and conversation patterns.

Features:
- Track concept recurrence (trigger hints on repeated mentions)
- Match preferences with current context
- Score hint relevance
- Emit hints via WebSocket (ws:proactive_hint)

Usage:
    engine = ProactiveHintEngine(vector_service, db_manager)
    hints = await engine.generate_hints(user_id, current_context)
"""
from __future__ import annotations
import logging
import hashlib
from typing import Any, Dict, List, Optional
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

# Prometheus metrics
try:
    from prometheus_client import Counter, Histogram
    PROMETHEUS_AVAILABLE = True

    proactive_hints_generated = Counter(
        "memory_proactive_hints_generated_total",
        "Proactive hints generated by type",
        ["type"]  # preference_reminder | intent_followup | constraint_warning
    )

    proactive_hints_relevance = Histogram(
        "memory_proactive_hints_relevance_score",
        "Relevance scores of generated hints",
        buckets=[0.0, 0.3, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    )
except ImportError:
    PROMETHEUS_AVAILABLE = False
    logger.debug("[ProactiveHintEngine] Prometheus client unavailable")


@dataclass
class ProactiveHint:
    """Structured hint for proactive suggestions."""
    id: str
    type: str  # "preference_reminder" | "intent_followup" | "constraint_warning"
    title: str
    message: str
    relevance_score: float
    source_preference_id: Optional[str] = None
    action_label: Optional[str] = None
    action_payload: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict for JSON serialization."""
        return asdict(self)


class ConceptTracker:
    """Track concept mentions and trigger hints on recurrence."""

    def __init__(self):
        self._concept_counters: Dict[str, int] = {}  # {user_id:concept: count}
        self._last_reset: Dict[str, datetime] = {}  # {user_id:concept: timestamp}
        self._reset_window = timedelta(hours=24)  # Reset counters after 24h

    def track_mention(self, user_id: str, concept: str) -> int:
        """
        Track concept mention and return current count.

        Auto-resets counter after 24h of inactivity.

        Args:
            user_id: User identifier
            concept: Concept mentioned

        Returns:
            Current count for this concept (after increment)
        """
        key = f"{user_id}:{concept}"
        now = datetime.now()

        # Check if counter needs reset (24h expired)
        last_reset = self._last_reset.get(key)
        if last_reset and (now - last_reset) > self._reset_window:
            self._concept_counters[key] = 0
            logger.debug(f"[ConceptTracker] Reset counter for {key} (24h expired)")

        # Increment counter
        self._concept_counters[key] = self._concept_counters.get(key, 0) + 1
        self._last_reset[key] = now

        count = self._concept_counters[key]
        logger.debug(f"[ConceptTracker] {key} mentioned {count} times")

        return count

    def reset_counter(self, user_id: str, concept: str) -> None:
        """Reset counter for specific concept (after hint emitted)."""
        key = f"{user_id}:{concept}"
        self._concept_counters[key] = 0
        self._last_reset[key] = datetime.now()
        logger.debug(f"[ConceptTracker] Counter reset for {key}")


class ProactiveHintEngine:
    """
    Generate proactive hints based on user preferences and context.

    Strategies:
    1. Preference reminder: Suggest when repeated concept matches preference
    2. Intent followup: Remind about uncompleted intentions
    3. Constraint warning: Alert when violating constraints
    """

    def __init__(self, vector_service, db_manager=None):
        """
        Initialize ProactiveHintEngine.

        Args:
            vector_service: VectorService instance for ChromaDB queries
            db_manager: Optional DatabaseManager for session queries
        """
        self.vector_service = vector_service
        self.db = db_manager
        self.concept_tracker = ConceptTracker()

        # Configuration
        self.max_hints_per_call = 3  # Max hints returned per generate_hints() call
        self.recurrence_threshold = 3  # Trigger hint after 3 mentions
        self.min_relevance_score = 0.6  # Min score to emit hint

        logger.info("[ProactiveHintEngine] Initialized (max_hints=3, recurrence_threshold=3)")

    async def generate_hints(
        self,
        user_id: str,
        current_context: Dict[str, Any]
    ) -> List[ProactiveHint]:
        """
        Generate proactive hints based on current context.

        Args:
            user_id: User identifier
            current_context: Dict with keys:
                - topic: Current conversation topic (str)
                - message: Last user message (str)
                - agent: Current agent ID (optional)
                - conversation_context: List of recent messages (optional)

        Returns:
            List of ProactiveHint objects (max 3, sorted by relevance)
        """
        if not user_id:
            logger.warning("[ProactiveHintEngine] generate_hints called without user_id")
            return []

        hints: List[ProactiveHint] = []

        try:
            # Extract concepts from current message
            topic = current_context.get("topic", "")
            message = current_context.get("message", "")

            # Simple concept extraction (can be enhanced with NLP)
            concepts = self._extract_concepts_simple(message or topic)

            # Strategy 1: Check concept recurrence â†’ preference reminders
            for concept in concepts[:5]:  # Limit to top 5 concepts
                count = self.concept_tracker.track_mention(user_id, concept)

                if count >= self.recurrence_threshold:
                    # Fetch related preferences
                    related_prefs = await self._fetch_related_preferences(user_id, concept)

                    if related_prefs:
                        hint = self._create_preference_reminder_hint(
                            concept=concept,
                            preferences=related_prefs,
                            count=count
                        )

                        if hint and hint.relevance_score >= self.min_relevance_score:
                            hints.append(hint)
                            self.concept_tracker.reset_counter(user_id, concept)

                            # Metrics
                            if PROMETHEUS_AVAILABLE:
                                proactive_hints_generated.labels(type="preference_reminder").inc()
                                proactive_hints_relevance.observe(hint.relevance_score)

            # Strategy 2: Intent followup (check for uncompleted intentions)
            intent_hints = await self._check_intent_followup(user_id, current_context)
            hints.extend(intent_hints)

            # Sort by relevance and limit
            hints.sort(key=lambda h: h.relevance_score, reverse=True)
            top_hints = hints[:self.max_hints_per_call]

            if top_hints:
                logger.info(
                    f"[ProactiveHintEngine] Generated {len(top_hints)} hints for user {user_id[:8]}"
                )

            return top_hints

        except Exception as e:
            logger.error(f"[ProactiveHintEngine] Failed to generate hints: {e}", exc_info=True)
            return []

    def _extract_concepts_simple(self, text: str) -> List[str]:
        """
        Simple concept extraction (keywords > 4 chars).

        Can be enhanced with NLP (spaCy, NLTK) in future.

        Args:
            text: Input text

        Returns:
            List of concepts (lowercase, deduplicated)
        """
        if not text:
            return []

        # Simple tokenization: split on spaces, filter length
        words = text.lower().split()
        concepts = [
            w.strip(".,!?;:\"'()[]{}")
            for w in words
            if len(w) > 4  # Min 5 chars
        ]

        # Deduplicate while preserving order
        seen = set()
        unique_concepts = []
        for c in concepts:
            if c not in seen:
                seen.add(c)
                unique_concepts.append(c)

        return unique_concepts[:10]  # Max 10 concepts

    async def _fetch_related_preferences(
        self,
        user_id: str,
        concept: str
    ) -> List[Dict[str, Any]]:
        """
        Fetch preferences related to concept via vector search.

        Args:
            user_id: User identifier
            concept: Concept to search

        Returns:
            List of preference records (metadata + text)
        """
        try:
            collection = self.vector_service.get_or_create_collection("emergence_knowledge")

            # Vector search for preferences matching concept
            results = self.vector_service.query(
                collection=collection,
                query_text=concept,
                n_results=3,  # Top 3 related preferences
                where_filter={
                    "$and": [
                        {"user_id": user_id},
                        {"type": "preference"},
                        {"confidence": {"$gte": 0.6}}  # High confidence only
                    ]
                }
            )

            preferences = []
            for r in results:
                preferences.append({
                    "id": r.get("id"),
                    "text": r.get("text"),
                    "metadata": r.get("metadata", {}),
                    "distance": r.get("distance", 1.0)
                })

            logger.debug(
                f"[ProactiveHintEngine] Found {len(preferences)} preferences for concept '{concept}'"
            )

            return preferences

        except Exception as e:
            logger.error(
                f"[ProactiveHintEngine] Failed to fetch preferences for '{concept}': {e}",
                exc_info=True
            )
            return []

    def _create_preference_reminder_hint(
        self,
        concept: str,
        preferences: List[Dict[str, Any]],
        count: int
    ) -> Optional[ProactiveHint]:
        """
        Create preference reminder hint.

        Args:
            concept: Recurring concept
            preferences: Related preferences
            count: Number of mentions

        Returns:
            ProactiveHint or None
        """
        if not preferences:
            return None

        top_pref = preferences[0]
        pref_text = top_pref.get("text", "")
        distance = top_pref.get("distance", 1.0)

        # Calculate relevance score (based on vector distance)
        # Lower distance = higher relevance
        relevance_score = max(0.0, 1.0 - distance)

        # Generate hint ID (deterministic hash)
        hint_id = hashlib.md5(f"pref_reminder:{concept}:{pref_text}".encode()).hexdigest()[:16]

        hint = ProactiveHint(
            id=hint_id,
            type="preference_reminder",
            title=f"Rappel: PrÃ©fÃ©rence dÃ©tectÃ©e",
            message=(
                f"ðŸ’¡ Tu as mentionnÃ© '{concept}' {count} fois. "
                f"Rappel de ta prÃ©fÃ©rence: {pref_text}"
            ),
            relevance_score=relevance_score,
            source_preference_id=top_pref.get("id"),
            action_label="Appliquer",
            action_payload={"preference": pref_text, "concept": concept}
        )

        return hint

    async def _check_intent_followup(
        self,
        user_id: str,
        current_context: Dict[str, Any]
    ) -> List[ProactiveHint]:
        """
        Check for uncompleted intentions and suggest followup.

        Args:
            user_id: User identifier
            current_context: Current conversation context

        Returns:
            List of intent followup hints
        """
        hints = []

        try:
            collection = self.vector_service.get_or_create_collection("emergence_knowledge")

            # Search for recent intentions (type="intent")
            results = self.vector_service.query(
                collection=collection,
                query_text=current_context.get("message", ""),
                n_results=2,
                where_filter={
                    "$and": [
                        {"user_id": user_id},
                        {"type": "intent"}
                    ]
                }
            )

            for r in results:
                intent_text = r.get("text", "")
                distance = r.get("distance", 1.0)
                relevance_score = max(0.0, 1.0 - distance)

                if relevance_score >= self.min_relevance_score:
                    hint_id = hashlib.md5(f"intent_followup:{intent_text}".encode()).hexdigest()[:16]

                    hint = ProactiveHint(
                        id=hint_id,
                        type="intent_followup",
                        title="Intention dÃ©tectÃ©e",
                        message=f"ðŸŽ¯ Rappel: {intent_text}. As-tu avancÃ© dessus?",
                        relevance_score=relevance_score,
                        source_preference_id=r.get("id"),
                        action_label="Oui, c'est fait",
                        action_payload={"intent": intent_text}
                    )

                    hints.append(hint)

                    # Metrics
                    if PROMETHEUS_AVAILABLE:
                        proactive_hints_generated.labels(type="intent_followup").inc()
                        proactive_hints_relevance.observe(relevance_score)

        except Exception as e:
            logger.error(f"[ProactiveHintEngine] Failed to check intent followup: {e}", exc_info=True)

        return hints
